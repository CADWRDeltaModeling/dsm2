helper class follow a particle.  When the particle reached a new node (make node decision), the helper will go to a dictionary and found a handler for the particle.  The particle will accept the handler and pass itself to the handler and the handler will do the handle

behavior could be site (loation) and time specific







interface Junction{                     interface JunctionHandler{
//accept a JunctionHandler              // handle the work according
// and a particle                       // to the junction and particle
 accept(JunctionHandler, Particle);     // given general so c
}                                           handle(Junction, Particle);
                                        }
Junctionhandler interface to generalize all junction handlers (e.g. swimming handler, dispatch handler) so a particle object doesn't need to know which handler it is dealing with.  the handle method here is equavelent to visit method in visit pattern
                                        
Class GSJunction                        Class GSJunctionDispatcher                               
    implements Junction{                    implements JunctionHandler{
  accept(jh, p){                          handle(j,p){
    /*                                    /* do either the regression
    check if jh is a GS Junction            model or flow split method */
    yes: jh.handle(this, p)             }  
    no: throw a cast error exception    Class BasicJunctionDispatcher
    */                                      implements JunctionHandler{
   }                                      handle(j, p){}
   /* carries other junction
   related info such as barrier
   operation schedules
   */
 }
 
 
 // every particle helper will be pushed in a  junction(or just general) helper list at the start of the program
 // e.g. a JunctionDispatchHelper, a JunctionSwimHelper
 // in the makeNodeDecision, the list will be gone through 
 // and use particlhelper.help()
 interface ParticleHelper{
    // give particle guidence if a junction or any environment condition changes
    void help(particle);
 }

// RouteslectionHelper better?
 Class JunctionDispatchHelper implement ParticleHelper{
 /* this class will be used to Match junctions with Dispatchers
    carries two maps both with node# as key and one with junction 
    and the other with dispatcher as values
    also carry a general dispatcher class for everybody
    
    !!!be aware the particle.nd is the node that the particle just encounted
        and particle.wb is the water body the particle currently in, not the water
        body the particle is going to.  it is the make()'s responsibility to assign 
        particle a new water body.
    !!! a particle.type also need to be added (e.g., salmon vs. smelt).
 */
    private Map<Integer, Junction> junctionMap; // node#, junction
    private Map<Integer, Map<ParticleType,JunctionDispatcher>> dispatcherMap;
    private GenericJunctionDispatcher gen;
    lookupJunction(node#){}
    lookupDispatcher(node#, ParticleType){}
    help(particle){
        Junction j = lookupJunction(...);
        JunctionDispatcher d = lookupDispatcher(...);
        if (j!=null and d!=null){
            j.accept(d, particle);
        }
    }
    
    // maybe this is better
    Class JunctionDispatchHelper implement ParticleHelper{
        // Integer takes node envIndex
        private Map<Integer, Map<ParticleType,JunctionDispatcher>> specialDispatchersMap;
        private BasicJunctionDispatcher gen;
        lookupDispatcher(nodeEnvIndex, ParticleType){//if cannot find in specialDispatchersMap, return gen}
        help(particle){
            JunctionDispatcher d = lookupDispatcher(...);
            if (d!=null){
                particle.accept(d);
            }
        }
 
    }
 
 
 //???
  Class JunctionSwimHelper implement ParticleHelper {
 /* this class will be used to Match junctions with swimmers
    carries two maps both with node# as key and one with junction 
    and the other with dispatcher as values
    also carry a general dispatcher class for everybody
 */
    private Map<Integer, Junction> junctionMap; // node#, junction
    private Map<Integer, Map<ParticleType,Swimmer>> swimmerMap;
    private GenericSwimmer gen;
    lookupJunction(node#){}
    lookupSwimmer(node#, ParticleType){}
    make(particle){
        Junction j = lookupJunction(...);
        JunctionSwimmer s = lookupDispatcher(...);
        if (j!=null and d!=null){
            j.accept(d, particle);
        }
    }
 
 }
 
 JunctionDispatchermaker is a type of observer to look afer particle and give a proper care taker (e.g. a swimmer or a dispatcher)
 should I make a array list for all observer's so that later if new observer need to be created it only need to push into the list and the code will go through the list and do the things needed to be done.
 
 junction could accept a swimmer or dispatcher.  but swimmer and dispatcher shares handler inferface.  As long as a handler is accepted leave the handler to do the handle.  junction disptcher msker will keep a map of only dispatchers (not e.g. swimmers). so for a single junction, it is unique dispatcher if the node# and type are defined.
 
 Do we need a overall observers to oversee all observes by pass in particle, node# wb# when reached a node?  This observer will decide if only a channel or a junction encounted and will act accordingly. 

When a particle reached a junction, it will go over the list of the observers (in this case junctionDispatcherMaker), then observer.make(...) 

Barriers

in initialize Barriers:
make a list of barriers

in setCurrentBarrierOp:
go through the list and set currentOp variable

In PTMEnv:


initialize in PTMEnv to get set of barriers and create a helper, helper get barriers from the set
when create a helper in PTMEnv 



