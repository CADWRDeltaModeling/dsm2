<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"><title>DSM2 Op Rule Guide</title>
<link type="text/css" href="../dsm2.css" rel="stylesheet"></head>
<body>
<div id="wrap">
<ul id="page_navbar" >
<li><a href="../toc.html">TOC</a></li>
</ul>
<div class="Section1"><hr style="">
<div id="page_title" class="dwr_logo"><h1>Operating Rule Guide</h1>
</div><!-- page_title--><hr style=""><h2><a name="Introduction"></a>Introduction</h2>
<p>DSM2 uses a text language for operating
rules, and the rules are stored in the database. Operating rules
combine <i>trigger</i> and <i>action</i>
directives, each of which is an <span style="font-style: italic;">expression</span>
based on observed model states, seasonal information and exogenous time
series input as well as other expressions. </p>
<p><i>Actions</i> are things the operating rule
does. In DSM2-DB, the actions affect either gate devices or source/sink
flow
boundaries. For gate devices the operating flow coefficient can be
changed.&nbsp; For sources and sinks, flow may be set to a new
constant value or a new time series. Expressions for
actions tend to be of the form:</p>
<p><span class="text_input">SET model_object TO
numerical_expression</span></p>
<p>The action becomes applicable when a corresponding <i>trigger</i>
goes from false to true. Triggers are written with expressions that
evaluate true or false:</p>
<p><span class="text_input">chan_stage(channel=132,
dist=1000) &lt; -0.1</span></p>
<p>Some rules are immediate responses to model conditions (close
the gate when stage dips below 0.5). Other rules use triggers to
describe seasons or situations where the action is applicable (reduce a
boundary flow when the month is between May and September). Still
others rules apply from the beginning of the run and the trigger column is
just a nuisance &#8211. </p>
<a name="Expressions"></a><h2>Expressions</h2>
<p>An expression is just a named quantity that is derived from
model data,&nbsp; outside time series data, math and time
functions. An example of a simple numerical expression based on current
DSM2-DB flow looks like this:</p>
<p><span class="text_input">ebb
:= chan_flow(channel=132, dist=1000) &gt; 0.01</span></p>
<p><span class="text_input"></span>This
example samples the current time step model flow 1,000
ft downstream of the upstream node in channel 132 and checks whether it
is
greater than 0.01 cfs. The expression assigns the answer the name <i>ebb</i>,
so it can be reused in later expressions. Note that <i>ebb</i>
is a logical
expression which evaluates to <i>true</i> or <i>false</i>
depending on the
model time step. Numerical expressions will be introduced shortly.</p>
<p>Assignments of named expressions always start with a name
the assignment operator &#8220;:=&#8221;. Spaces around the assignment and
greater-than
operators are optional. The assignment operator isn&#8217;t actually used in
the GUI,
because there is a separate column for the name and definition.</p>
<p>The <i>chan_flow</i> part of the expression
represents the
value of a model variable. Model variables typically require <i>identifiers</i>,
which are included in parenthesis and are a comma-separated list with
elements
that depend on the context (see the section below on DSM2 model
variable
identifiers). These identifiers can be numerical or text strings:</p>
<p><span class="text_input">chan_flow(channel=132,
dist=1000</span>) ...numerical</p>
<p><span class="text_input">gate_op(gate=middle_river_barrier,
device=weir) </span>...strings</p>
<p>The examples thus far have
been logical expressions. Logical expressions usually appear in
triggers rather than actions. Besides
logical
expressions, expressions that evaluate to numerical values can be
defined:<span class="text_input"><br></span></p><p><span class="text_input">ebbmagnitude
:= log(chan_flow(channel=132, dist=1000))</span></p>
<p>and expressions can also involve simple math operators. For
instance:</p>
<p><span class="text_input">ebbmagnitude
:= log(chan_flow(channel=132, dist=1000))</span></p>
<p>is an expression that evaluates flow, applies the log
function to it and then assigns it to the variable name <i>ebbmagnitude</i>.
For details, see the section below on Math Operators)</p>
<p>Model time can also be used in expressions. The following
expression describes the VAMP season for San Joaquin river management:</p>
<p><span class="text_input">vamp := (MONTH == APR)
or (MONTH == MAY)</span>
</p><p>The definition could also include the date, day of
the
month, or time of day. </p>
month, or time of day. <p></p>
<p>Finally, the following example combines a model state
(stage/water surface) observation, an external time series (called
tide_level)
and some simple arithmetic. The expression might be used with a slowly
fluctuating tide or sea level datum to provide an idea of critical
stage in the
South Delta compared to ambient tide conditions.</p>
<p><span class="text_input">critical_stage
:= chan_stage(channel=132,dist=1000)&lt;(tide_level-1.0)</span></p>
<a name="Operating Rules"></a><h2>Operating
Rules</h2>
<p>It is now straightforward to use expressions in operating
rules. The following example is based on expressions that
were developed above. <b>Bold face</b> words correspond to
tables or columns of the GUI.</p>
<dl class="field_definitions"><dt>Name</dt><dd class="text_input">middle_vamp_ebb</dd>
<dt>Expressions</dt><dd class="text_input">ebb
:= chan_flow(channel=132, dist=1000) &gt; 0.01</dd>
<dd class="text_input">vamp := (month == Apr) OR (month ==
May)</dd>
<dt>Trigger</dt><dd class="text_input">vamp
AND ebb</dd>
<dt>Action</dt><dd class="text_input">SET
gate_op(gate=middle_river_barrier,
device=weir) TO ts(new_time_series)</dd>
</dl><p>The <i>middle_vamp_ebb</i> operating
rule lies
dormant until
the first time step when <i>vamp and ebb</i> (a compound
expression based on
the expressions <b>vamp</b> and <b>ebb</b>)
becomes true. At that point the action will be taken and the weir
operating coefficient will start to
operate according to the values in the DSS time series <i>new_time_series.</i>
Note that except for the expression definitions, the parts of this
operating
rule can be united using the name assignment (:=) and WHERE directives:</p>
<p><span class="text_input">middle_vamp_ebb</span>
:=
SET <span class="text_input">gate_op(gate=
middle_river_barrier,device = weir) TO
ts(new_time_series)
WHERE (vamp AND ebb)</span></p>
<p>This is the form of the operating rule that would be used,
say, when parsing a text file rather than using the GUI.</p>
<h2><a name="Prediction"></a>Prediction</h2>
<p>Anticipation using linear or quadratic extrapolation can be
added to numerical expressions in expressions using the PREDICT
function. What is nice about PREDICT is that it allows trigger expressions to more
accurately express the intent of a rule, because you don't need "buffers" which
are confusing and inaccurate.</p>
<p>For instance lets say you want to take some action like
close a gate to protect stage in channel 206 in the South Delta from
going
below zero. If you use a buffer, you write the following:</p>
<p><span class="text_input">SET
[some action] WHEN chan_stage(chan=206, dist=0) &lt;1);</span></p>
<p>This is confusing because the value "1" is used as
the trigger criterion when the intent has to do with stage of 0 and not
1. It
is inaccurate because it will go off no matter what the trend is. With
anticipation, the same rule would look like this: </p>
<p><span class="text_input">SET
[some action] WHEN PREDICT(chan_stage(chan=206, dist=0),LINEAR, 30MIN)
&lt; 0;</span></p>
<p>This states the trigger clearly in terms of the value 0. It
is also much less likely to go off by accident, because the time trend
is used
(stage going below 1 is not significant if it is dropping very slowly
and not
likely to make it to 0). In addition to LINEAR extrapolation quadratic
predictions are available using QUAD as the second argument to PREDICT.
Over
time periods of less than an hour (and not right next to a gate or
reservoir),
quadratic interpolation is markedly more accurate than linear.</p>
<a name="RAMP Transition"></a><h2>RAMP
(transition)</h2>
<p>For actions, there is also a way to smooth time. The keyword
RAMP after an action (together with a number of minutes) will
transition in the
action gradually, if such a transition makes physical sense.</p>
<p>For instance, a ramping version of <i>middle_vamp_ebb</i>
might use the definition for ebb:</p>
<p><span class="text_input">SET
gate_op( gate=middle_r_barrier, device=radial) TO ts(new_time_series)
RAMP 60min</span></p>
<a name="Complementary Triggers"></a><h2>Complementary
Triggers and IFELSE</h2>
<p>Often, an operating rule is paired with a complimentary rule
that will reverse its action. For instance, to complement the above
rule for
ebb flow the following operating rule for flood flow might be added:</p>
<dl class="field_definitions"><dt>Name</dt><dd class="text_input">middle_vamp_flood</dd>
<dt>Expressions</dt>
<dd class="text_input">flood := chan_flow(channel=132,
dist=1000) &lt; -0.01</dd>
<dd class="text_input">vamp := (month == Apr) or (month ==
May)</dd>
<dt>Trigger</dt><dd class="text_input">vamp
and flood</dd>
<dt>Action</dt><dd class="text_input">SET
gate_op( gate=middle_r_barrier, device=barrier,direction=to_node) TO
old_time_series</dd>
</dl><p>This rule effectively undoes the ebb action. The
example underscores a necessary but somewhat unintuitive
point about triggers: they are one-time and unidirectional. A rule
whose trigger is <i>vamp and ebb</i> will activate when
this expression changes from false to true but will not do anything or even
notice if <i>vamp and ebb</i> subsequently becomes false again. If the
complementary behavior is desired, this intent must be specified in a second rule. Often the
complementary rule is subtly different from the exact negation of the original; for instance, the
trigger&nbsp;<span style="">vamp and flood </span>&nbsp;
is not the same as <span style="font-family: &quot;Courier New&quot;;">not(vamp
and ebb)</span>.
&nbsp; In the case of the
Montezuma Salinity Control Structure, the flood and ebb triggers are
not even based on the same variable (the gate is opened based on a head
difference, closed based on velocity).</p>
<p>The <i>middle_vamp_ebb</i> example combines <i>vamp,</i>
which is the seasonal applicability of the rule with <i>ebb</i>,
which is a
tidal phenomenon.&nbsp; There are also meaningful operating rules
that do not need a trigger at all.&nbsp; For instance, the user
might want to operate SWP and CVP pumping based on a time series 
but bound it by some fraction of
Sacramento inflow.&nbsp; The trigger in this case is 
&#8220;TRUE&#8221; and it will go off once at startup. This 
is the default in the GUI if you leave the trigger blank.</p>
<p>If what you really want is a trigger that continuously
monitors a true-false condition and applies a value accordingly, you
may want to consider using the IFELSE function and no trigger. For
instance:</p>
<p class="text_input">SET ext_flow(node=17) TO IFELSE(
vamp, ts1, ts2)</p>
will set the boundary flow at node 17 (San Joaquin River) to time
series ts1 whenever vamp is true and to ts2 when vamp is not true.<p></p>
<a name="Misfires"></a><h2>Misfires and
Redundant Triggering</h2>
<p>Extra triggering and rule activation may seem harmless when
you consider one rule in isolation. Rerunning an action hurts
performance, but the action is redundant rather than harmful. The real
problem with
rules that misfire is that they are active too often and tend to
interfere with
(&#8220;lock out&#8221; or &#8220;bump&#8221;) other rules that are trying to manipulate the
same
model variable.</p>
<p>Here is an example of misfiring trigger based on an
expression using date terms:</p>
<p><span class="text_input">(YEAR &gt;= 1990 AND
MONTH&gt;=APR AND DAY&gt;=14)</span></p>
<p>(note: a much better way to write this expression using the
DATE keyword is given in the reference section)</p>
<p>Because of the <span class="text_input">ANDs</span>,
this expression requires three conditions to be true at once in order
to evaluate to TRUE. It goes off as intended on or about 14APR1990. But
what happens on 01MAY1990? On 14MAY1990? This trigger is going to
evaluate
to FALSE and then back to TRUE. When it makes the FALSE-TRUE transition
it will
cause the trigger to go off, which is probably not what was intended.</p>
<p>There is a fix for the above expression (not the recommended
on) that illustrates that <i>the only thing that matter are
FALSE-TO-TRUE transitions. </i>There is one more curious point
about this
example is that the correct behavior is obtained using:</p>
<p><span class="text_input">(YEAR == 1990 AND MONTH
==
APR AND DAY &gt;= 14) </span></p>
<p>Why? The rule will evaluate FALSE on or about 01MAY1990, but
it will stay false!</p>
<p>These date examples are so common that there is a special
way of dealing with them. See the function reference for <a href="#DATE">DATE and SEASON.</a></p>
<a name="TRUE"></a><h2>Default (TRUE) Trigger</h2>
<p>If you leave the trigger definition blank in the GUI the
trigger expression will be set to WHEN TRUE. </p>
<p>The TRUE trigger is roughly equivalent to "at startup" and
you should be sure not to confuse it with "always true". 
Recall it is transitions that are important, and this trigger 
makes its only nominal FALSE-TO-TRUE
transition once at the very beginning of the run.  Once displaced by
an overlapping action, the rule will never activate again </p> 
<p>A rule that evaluates to a trivial FALSE will never do anything.</p>
<p>As an example of a situation where these concepts matter, 
consider a rule that toggles use of a gate for the entire simulation. 
By default, a gate in the model is installed. Assume we have
set up an expression named use_barriers or remove_barriers
indicating whether we want to use gates. Three possibilities 
for writing the rule are:</p>
<table><tbody>
<tr><td></td><td>TRIGGER</td><td>ACTION</td><td></td></tr>
<tr class="text_input"><td>1.</td><td>TRUE</td><td>SET gate_install(gate=...) </td><td>TO use_gate</td></tr>
<tr class="text_input"><td>2.</td><td>use_gate</td><td>SET gate_install(gate...) </td><td>TO INSTALL </td></tr>
<tr class="text_input"><td>3.</td><td>remove_gate</td><td>SET gate_install(gate=...) </td><td>TO REMOVE</td></tr>
</tbody></table>

<p>Option 1 uses the default trigger. It will be activated at startup and the gate installation
will be set to the expression variable use_gate. 
Option 2 is interesting because it will never do anything useful. It will be evaluated once
at the start of the run, but it will never trigger if use_gate is FALSE. It will
trigger if use_gate is TRUE, but this merely carries out the default. 
Option 3 remedies this by using remove_gate -- the non-default -- as the trigger. 
Different users seem to regard different options (1) and (3) more intuitive.</p>

<a name="Conflicts"></a><h2>Conflicts</h2>
<p>When a rule is triggered, it will be activated unless it
conflicts with another, active rule. Rules conflict when they operate
on the
same model variable. For instance, two rules that act to change a weir
coefficient in the same gate/weir conflict.</p>
<p>Two specifications govern conflicts:</p>
<p>1. When a rule conflicts with an active rule it is deferred.
Deferred rules are not activated, but they are tricked into thinking
they
evaluated FALSE so that the can possibly make a FALSE-TRUE transition
again the
next time step.</p>
<p>2. When a rule conflicts with another potentially activating
rule, the results are &#8220;undefined&#8221;. We are unaware of any universal
solution in
this situation. The best solution is to write rules that don&#8217;t do this
&#8211; we are
currently working on a better warning system to detect when this
happens.</p>
<h2><a name="Function Reference"></a>DSM2
Variable and Function Reference:</h2>
<h3><a name="Variables"></a>Variables</h3>
<p>The variables from DSM2 that
can be used in operating rules
include boundary and grid variables that can be changed and those that
are merely observable (read-only). The observable variables are divided
between variables that can be set to time series (Dynamic Variables)
that will apply ever-after and variables that can only be set to new
static values (Static Variables)</p>
<h4><a name="Dynamic"></a>Dynamic Control
Variables</h4>
<p>These variables are
dynamically controllable and can be set to
a time series. Once the new time series is set, the boundary or
structure
being controlled will have no memory of its old controlling time
series. Most dynamic variables are gate and boundary data.</p>
<dl class="code_reference"><dt>gate_op(gate=textname,device=textname,
<p>direction=[to_node|from_node|to_from_node])</p></dt>
<dd>Device operating coefficients (0..1) in corresponding
direction. Use keywords CLOSE (=0) and OPEN (=1) to make rules more
readable. The option "to_from_node" is write-only -- a convenience feature that writes to
two otherwise separate variables.
</dd><dt>gate_position(gate=textname,device=textname)</dt><dt>
</dt><dd>Physical operation of control structure such as
radial gate height (physical units). The interpretation of "position" is dependent on
the "control_type" of the gate. If it is gated from the bottom, position indicates elevation and is the same
as elev. If the control type is gated from the top, as in a radial gate, the position is the height. This variable
is deprecated now, in favor of directly using "elev" or "height".
<dt>gate_height(gate=textname,device=textname)</dt><dd>
Height of gate device.</dd>
<dt>gate_elev(gate=textname,device=textname)</dt><dd>
Crest elevation or invert elevation of gate device.</dd>
<dt>gate_width(gate=textname,device=textname)</dt><dd>
Width or radius of gate device.</dd>
</dd>
<dt>ext_flow(name=textname)</dt><dd>External
flow (boundary flows, source/sink)</dd>
<dt>transfer_flow(transfer=textname)</dt>
<dd>Flows in object-to-object transfers</dd></dl>
<h4><a name="static"></a>Static Control Variables</h4>
<p>These are variables that are normally static. You can set them
to a constant. If you set them to a time series, the model will not
complain, but the result may not be what you expect. The model variable
will only be set to the <em>current</em>
value of the series at the time the rule was activated. The variable
won't keep changing with the time series.
</p><dl class="code_reference">
<dt>gate_install(gate=textname)</dt>
<dd>Determines or inquires whether the given gate is installed. 
<p class="text_input">SET gate_install(...) TO [REMOVE|FALSE]</p>
<p>completely removes the gate and restores an equal-stage compatibility
condition to the channel junction.</p> 
<p class="text_input">SET gate_install(...) TO [INSTALL|TRUE]</p> 
<p>installs the gate.</p>
</dd>
<dt>gate_coef(gate=textname,device=textname, <p>direction=[to_node|from_node])</p></dt>
<dd>Gate coefficient of the device in the given direction. This
is a <em>physical</em> quantitity of the structure,
representing the roughness or efficiency of flow. It should not be used
for operating controls such as flap gates.
The coefficients will change only rarely when the actual site is
altered and should never leave the range (0,1).
</dd><dt>gate_nduplicate(gate=textname,device=textname)</dt>
<dd>Number of duplicate devices.</dd>
</dl><a name="observable"></a><h4>Observable
Variables</h4>
<p>These are read-only model variables that cannot be manipulated
directly, but can be observed and used in expressions for triggers and
actions. </p>
<dl class="code_reference"><dt>chan_flow(channel=number,dist=[number|length])</dt>
<dd>Flow in channel.dist=length indicates the end of the channel.</dd>
<dt>chan_vel(channel=number, dist=[number|length])</dt>
<dd>Velocity at given channel and distance.</dd>
<dt>chan_stage(channel=number,dist=[number|length])</dt>
<dd>Water Surface at given channel and distance.</dd>
<dt>chan_surf</dt><dd>Same as stage (water surface)
in channel</dd>
<dt>res_stage(res=textname)</dt><dd>Water surface in
reservoir</dd>
<dt>res_flow(res=textname, node=number)</dt><dd>Flow
from reservoir to node</dd>
<dt>ts(name=textname)</dt><dd>Any time series named
in the Operating Rule View of the GUI may be used by referencing the
name. Time series evaluate
to their value at the current time step.</dd>
</dl><h3><a name="Time"></a>Model Time
Queries</h3>
<p>The following commands retrieve model date or seasonal
information:</p>
<dl class="code_reference"><dt>YEAR, MONTH, DAY</dt>
<dd>Retrieves the year, month and day associated with the current
model time step. These
are returned as numbers. When testing them, you can (for clarity) use
3-letter abbreviations for the months. Examples:
<p class="text_input">YEAR &gt;= 1991</p>
<p class="text_input">MONTH + 1 &lt; MAY</p>
</dd><dt>HOUR, MIN</dt><dd>Retrieve the (24
hour) hour and minute associated with the current model time step.</dd>
<a name="DATE"></a><dt>DATE</dt><dd>Returns
a time stamp corresponding to the beginning of the day on
the current model date. Example:
<p class="text_input">DATE &gt;= 11OCT1992 (not time
part)</p></dd>
<dt>DT</dt><dd>Represents the model time step in seconds. This is often
useful for use with ACCUMULATE</dd>
<dt>DATETIME</dt><dd>Returns a time stamp
corresponding to the current model date and time. Example:
<p class="text_input">DATETIME &gt; 04FEB1990 00:00
(date plus time)</p></dd>
<dt>SEASON</dt><dd>Returns a time stamp <em>
relative to the beginning of the year</em>
corresponding to the beginning of the day on the current model date and
time. Comparisons such as <span class="text_input">SEASON
&gt; 15APR AND SEASON &lt;01MAY</span>
avoid common logical mistakes from building this from scratch. <p>There
is one other gotcha with SEASON that comes up at the end of time
periods because the timestamp is always at 00:00. Compare <span class="text_input"> SEASON &gt; 15APR AND SEASON
&lt;01MAY</span>
<span class="text_input"> SEASON &gt; 15APR AND SEASON
&#8804;30APR</span>
and notice that the latter does not include the entire day 30APR.
</p></dd></dl><p>Note SEASON and DATE/DATETIME
to combined expressions
built from atomic expressions like day and month. They are clearer and
avoid some curious gotchas. For instance <span class="text_input">DATE
&gt;= 14APR1990</span> will
evaluate true only once per year, whereas <span class="text_input">(YEAR
&gt;= 1990 AND MONTH&gt;=APR AND
DAY&gt;=14)</span>
will evaluate true on Apr 14, false on May 1 and true again on May 14.
You
could get the intended behavior with <span class="text_input">(YEAR
== 1990 AND MONTH == APR AND
DAY&gt;=14)</span>, which will go from false to true only
once, but the fix hardly seems
worth the trouble.</p>
<a name="numerical"></a><h3>Numerical
Operations</h3>
<p>The following operators and functions are available</p>
<dl class="code_reference">
<dt>+, -, *, /</dt><dd>Arithmetic
operators with standard precedence of operations. You can use
parenthesis to change the evaluation order.</dd>
<dt>x^3, x^y</dt> <dd>Power of x and x to the power
of y</dd>
<dt>MIN2(x,y)</dt><dd>Minimum of two arguments.</dd>
<dt>MAX2(x,y)</dt><dd>Maximum of two arguments.</dd>
<dt>MIN3(x,y,z)</dt><dd>Minimum of three arguments.</dd>
<dt>MAX3(x,y,z)</dt><dd>Maximum of three arguments.</dd>
<dt>SQRT(x)</dt> <dd>Square root of x</dd>
<dt>EXP(x) </dt> <dd>Exponent function (e to the
power of x)</dd>
<dt>LN(x)</dt> <dd>Natural log of x</dd>
<dt>LOG(x)</dt> <dd>Base 10 log of x</dd>
</dl><a name="logical"></a><h3>Logical
Operations</h3>
<dl class="code_reference"><dt>x==y</dt><dd>Tests
equality.</dd>
<dt>x&lt;&gt;y</dt><dd>Tests inequality.</dd>
<dt>x&lt;y,x&gt;y, x&lt;=y, x&gt;=y</dt><dd>Comparisons.</dd>
<dt>TRUE</dt><dd>The value TRUE</dd>
<dt>FALSE</dt><dd>The value FALSE</dd>
<dt>NOT <i>expression</i></dt><dd>Negation
of <i>expression</i>,
as in <span class="text_input">NOT(x &lt; y)</span>
</dd><dt><i>expr1</i> AND <i>expr2</i></dt><dd>Logical
&#8216;and&#8217;, which evaluates to TRUE only if both the expressions it joins
are true. Expression
(<i>expr2</i>) will not be evaluated if <i>expr1</i>
evaluates to FALSE.</dd>
<i>expr1</i> OR <i>expr2</i><dd>Logical
&#8216;or&#8217;</dd>
</dl><h3>Special Functions</h3>
<dl class="code_reference"><dt>ACCUMULATE(<i>expression</i>,
<i>initval </i>[,<i>resetcond]</i>)</dt>
<dd>Cumulative value function. Accumulates additively the value
of <i>expression</i>
using <i>initval</i> (another numerical expression) as the
initial condition
and resetting the total anytime the <i>resetcond</i>
evaluates to true. If you want to integrate 
you should multiply the <i>expression</i> by DT or else
your rule won't be robust if someone changes the time step.</dd>
<dt>IFELSE(<i>boolexpr</i>, <i>valexp1</i>,<i>valexpr2</i>)</dt>
<dd>The ternary operator. If <i>boolexpr</i> returns
<i>true</i>, returns the value given by <i>valexpr1</i>.
If <i>boolexpr</i> returns <i>false</i>,
returns the value given by <i>valexpr2</i>.</dd>
<dt>LOOKUP(<i>expression</i>, <i>lookup_array</i>,<i>value_array</i>)</dt>
<dd>Lookup values from a small user supplied table. The lookup array is provided using
 a bracketed, comma-separated list of values such as <i>[1000.,2000.,3000.]</i>. 
 The value_array return values are similar but must have a length one smaller than
the number of lookup values.  The array values must be hard-wired numbers at the present time -- 
expressions are not allowed. 
The LOOKUP compares <i>expression</i> to elements of lookup_array. The highest
element of the lookup table is currently a limit, not an actual lookup slot.
The function returns the component of value_array corresponding to the highest index 
in lookup array that is <= <i>expression</i>, e.g.:
<p>LOOKUP(1000.,[1000.,2000.,3000.], [1.,2.]) returns 1.</p>
<p>LOOKUP(2000.,[1000.,2000.,3000.], [1.,2.]) returns 2.</p>
<p>LOOKUP(3000.,[1000.,2000.,3000.], [1.,2.]) is an error.</p>
</dd>
<p></p></dl></div></div></body></html>